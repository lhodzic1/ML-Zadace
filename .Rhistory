#predictions <- predict(model, newdata = subset(weather_data_test, select = -
#c(RainTomorrow)), type= "response")
#predictions[predictions > 0.5] <- "Yes"
#predictions[predictions <= 0.5] <- "No"
#predictions <- factor(predictions, levels = c("No", "Yes"))
#cm <- confusionMatrix(data = predictions, reference = weather_data_test$RainTomorrow)
#draw_confusion_matrix(cm)
##knn
#predictions <- knn(train = subset(podaci_train, select = -c(RainTomorrow)),
# test = subset(weather_data_test, select = -c(RainTomorrow)),
# cl = podaci_train$RainTomorrow, k = 3)
#cm <- confusionMatrix(data = predictions, reference = weather_data_test$RainTomorrow)
#draw_confusion_matrix(cm)
#neuralne
#test_accuracy_test(model_multiple_layers)
# normalizacija podataka
podaci$RainTomorrow[podaci$RainTomorrow == "1"] <- 0
podaci$RainTomorrow[podaci$RainTomorrow == "2"] <- 1
preObj <- preProcess(subset(podaci, select = -c(RainTomorrow)),
method=c("range"), rangebounds = c(0, 1))
class <- podaci$RainTomorrow
podaci <- predict(preObj, subset(podaci, select = -c(RainTomorrow)))
podaci$RainTomorrow <- class
# podjela na trening i testni skup
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]
end <- length(podaci$RainTomorrow)
n <- as.integer(0.8 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
podaci <- read.csv("weather_data_train.csv", fileEncoding = 'UTF-8')
podaci <- podaci[-c(70, 550), ]
Location_not_na <- subset(podaci, is.na(Location) == FALSE)$Location
MinTemp_not_na <- subset(podaci, is.na(MinTemp) == FALSE)$MinTemp
MaxTemp_not_na <- subset(podaci, is.na(MaxTemp) == FALSE)$MaxTemp
Rainfall_not_na <- subset(podaci, is.na(Rainfall) == FALSE)$Rainfall
WindGustDir_not_na <- subset(podaci, is.na(WindGustDir) == FALSE)$WindGustDir
WindGustSpeed_not_na <- subset(podaci, is.na(WindGustSpeed) == FALSE)$WindGustSpeed
RainToday_not_na <- subset(podaci, is.na(RainToday) == FALSE)$RainToday
Humidity9am_not_na <- subset(podaci, is.na(Humidity9am) == FALSE)$Humidity9am
Cloud9am_not_na <- subset(podaci, is.na(Cloud9am) == FALSE)$Cloud9am
Cloud5pm_not_na <- subset(podaci, is.na(Cloud5pm) == FALSE)$Cloud5pm
Pressure9am_not_na <- subset(podaci, is.na(Pressure9am) == FALSE)$Pressure9am
WindDir9am_not_na <- subset(podaci, is.na(WindDir9am) == FALSE)$WindDir9am
WindDir3pm_not_na <- subset(podaci, is.na(WindDir3pm) == FALSE)$WindDir3pm
RainTomorrow_not_na <- subset(podaci, is.na(RainTomorrow) == FALSE)$RainTomorrow
#Zamjena nedostajucih vrijednosti kolone MinTemp
podaci_stari <- podaci
median <- median(MinTemp_not_na)
for (i in 1 : length(podaci$MinTemp))
{
if (is.na(podaci$MinTemp[i]) == TRUE)
{
podaci$MinTemp[i] <- median
}
}
#Zamjena nedostajucih vrijednosti kolone MaxTemp
podaci_stari <- podaci
median <- median(MaxTemp_not_na)
for (i in 1 : length(podaci$MaxTemp))
{
if (is.na(podaci$MaxTemp[i]) == TRUE)
{
podaci$MaxTemp[i] <- median
}
}
#Odbacivanje outlier-a za MaxTemp
median <- median(MaxTemp_not_na)
for (i in 1 : 9)
{
index_maximuma <- which.max(podaci$MaxTemp)
podaci$MaxTemp[index_maximuma] <- median
index_minimuma <- which.min(podaci$MaxTemp)
podaci$MaxTemp[index_minimuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Rainfall
podaci_stari <- podaci
median <- median(Rainfall_not_na)
for (i in 1 : length(podaci$Rainfall))
{
if (is.na(podaci$Rainfall[i]) == TRUE)
{
podaci$Rainfall[i] <- median
}
}
#Odbacivanje outlier-a kolone Rainfall
median <- median(Rainfall_not_na)
for (i in 1 : 50)
{
index_maximuma <- which.max(podaci$Rainfall)
podaci$Rainfall[index_maximuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone WindGustSpeed
podaci_stari <- podaci
median <- median(WindGustSpeed_not_na)
for (i in 1 : length(podaci$WindGustSpeed))
{
if (is.na(podaci$WindGustSpeed[i]) == TRUE)
{
podaci$WindGustSpeed[i] <- median
}
}
#Odbacivanje outlier-a za WindGustSpeed
median <- median(WindGustSpeed_not_na)
for (i in 1 : 5)
{
index_minimuma <- which.min(podaci$WindGustSpeed)
podaci$WindGustSpeed[index_minimuma] <- median
}
for (i in 1 : 50)
{
index_maximuma <- which.max(podaci$WindGustSpeed)
podaci$WindGustSpeed[index_maximuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Humidity9am
podaci_stari <- podaci
median <- median(Humidity9am_not_na)
for (i in 1 : length(podaci$Humidity9am))
{
if (is.na(podaci$Humidity9am[i]) == TRUE)
{
podaci$Humidity9am[i] <- median
}
}
#Odbacivanje outlier-a za Humidity9am
median <- median(Humidity9am_not_na)
for (i in 1 : 50)
{
index_minimuma <- which.min(podaci$Humidity9am)
podaci$Humidity9am[index_minimuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Cloud9am
podaci_stari <- podaci
median <- median(Cloud9am_not_na)
for (i in 1 : length(podaci$Cloud9am))
{
if (is.na(podaci$Cloud9am[i]) == TRUE)
{
podaci$Cloud9am[i] <- median
}
}
#Zamjena nedostajucih vrijednosti kolone Pressure9am
podaci_stari <- podaci
median <- median(Pressure9am_not_na)
for (i in 1 : length(podaci$Pressure9am))
{
if (is.na(podaci$Pressure9am[i]) == TRUE)
{
podaci$Pressure9am[i] <- median
}
}
#Odbacivanje outlier-a za Pressure9am
median <- median(Pressure9am_not_na)
for (i in 1 : 30)
{
index_minimuma <- which.min(podaci$Pressure9am)
podaci$Pressure9am[index_minimuma] <- median
}
for (i in 1 : 20)
{
index_maximuma <- which.max(podaci$Pressure9am)
podaci$Pressure9am[index_maximuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Cloud5pm
podaci_stari <- podaci
median <- median(Cloud5pm_not_na)
for (i in 1 : length(podaci$Cloud5pm))
{
if (is.na(podaci$Cloud5pm[i]) == TRUE)
{
podaci$Cloud5pm[i] <- median
}
}
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
#Popunjavanje nedostajucih vrijednosti kolone Location
podaci$Location[is.na(podaci$Location)] = getmode(Location_not_na)
#Popunjavanje nedostajucih vrijednosti kolone WindGustDir
podaci$WindGustDir[is.na(podaci$WindGustDir)] = getmode(WindGustDir_not_na)
#Popunjavanje nedostajucih vrijednosti kolone RainToday
podaci$RainToday[is.na(podaci$RainToday)] = getmode(RainToday_not_na)
#Popunjavanje nedostajucih vrijednosti kolone WindDir9am
podaci$WindDir9am[is.na(podaci$WindDir9am)] = getmode(WindDir9am_not_na)
#Popunjavanje nedostajucih vrijednosti kolone WindDir3pm
podaci$WindDir3pm[is.na(podaci$WindDir3pm)] = getmode(WindDir3pm_not_na)
#Odbacivanje varijabli sa visokim stepenom korelacije
podaci <- select(podaci, -MaxTemp, -Cloud5pm)
#normalizacija podataka
max <- max(podaci$Pressure9am)
min <- min(podaci$Pressure9am)
podaci <- mutate(podaci, Pressure9am = (Pressure9am - min) / (max - min))
# pretvaranje kategorickih varijabli u numericke
podaci$WindGustDir <- as.numeric(factor(podaci$WindGustDir))
podaci$WindDir9am <- as.numeric(factor(podaci$WindDir9am))
podaci$WindDir3pm <- as.numeric(factor(podaci$WindDir3pm))
podaci$RainToday <- as.numeric(factor(podaci$RainToday))
podaci$Location <- as.numeric(factor(podaci$Location))
#SMOTE
library(smotefamily)
options(warn = -1)
new_data <- SMOTE(X = subset(podaci, select = -c(RainTomorrow)), target =
podaci$RainTomorrow, K = 7, dup_size = 0)$data
new_data$RainTomorrow <- factor(new_data$class)
new_data <- subset(new_data, select = -c(class))
podaci <- new_data
#podaci$WindGustDir <-as.factor(podaci$WindGustDir)
#podaci$WindDir9am <- as.factor(podaci$WindDir9am)
#podaci$WindDir3pm <- as.factor(podaci$WindDir3pm)
#podaci$RainToday <- as.factor(podaci$RainToday)
#podaci$Location <- as.factor(podaci$Location)
#Podjela dataset-a na trening i testni skup
set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]
end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
podaci$RainTomorrow <- as.numeric(factor(podaci$RainTomorrow))
# normalizacija podataka
podaci$RainTomorrow[podaci$RainTomorrow == "1"] <- 0
podaci$RainTomorrow[podaci$RainTomorrow == "2"] <- 1
preObj <- preProcess(subset(podaci, select = -c(RainTomorrow)),
method=c("range"), rangebounds = c(0, 1))
class <- podaci$RainTomorrow
podaci <- predict(preObj, subset(podaci, select = -c(RainTomorrow)))
podaci$RainTomorrow <- class
# podjela na trening i testni skup
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]
end <- length(podaci$RainTomorrow)
n <- as.integer(0.8 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
weather_data_test <- read.csv("weather_data_test.csv", fileEncoding = 'UTF-8')
#Pretvaranje kategorickih varijabli u faktorske
#weather_data_test$WindGustDir <- factor(weather_data_test$WindGustDir)
#weather_data_test$WindDir9am <- factor(weather_data_test$WindDir9am)
#weather_data_test$WindDir3pm <- factor(weather_data_test$WindDir3pm)
#weather_data_test$RainToday <- factor(weather_data_test$RainToday)
#weather_data_test$RainTomorrow <- factor(weather_data_test$RainTomorrow)
#weather_data_test$WindGustDir <- factor(weather_data_test$WindGustDir, levels = levels(podaci$WindGustDir))
#weather_data_test$WindDir9am <- factor(weather_data_test$WindDir9am, levels = levels(podaci$WindDir9am))
#weather_data_test$WindDir3pm <- factor(weather_data_test$WindDir3pm, levels = levels(podaci$WindDir3pm))
#weather_data_test$RainToday <- factor(weather_data_test$RainToday, levels = levels(podaci$RainToday))
#weather_data_test$RainTomorrow <- factor(weather_data_test$RainTomorrow, levels = levels(podaci$RainTomorrow))
weather_data_test <- select(weather_data_test, -MaxTemp, -Cloud5pm)
max <- max(weather_data_test$Pressure9am)
min <- min(weather_data_test$Pressure9am)
weather_data_test <- mutate(weather_data_test, Pressure9am = (Pressure9am - min) / (max - min))
weather_data_test$WindGustDir <- as.numeric(factor(weather_data_test$WindGustDir))
weather_data_test$WindDir9am <- as.numeric(factor(weather_data_test$WindDir9am))
weather_data_test$WindDir3pm <- as.numeric(factor(weather_data_test$WindDir3pm))
weather_data_test$RainToday <- as.numeric(factor(weather_data_test$RainToday))
weather_data_test$RainTomorrow <- as.numeric(factor(weather_data_test$RainTomorrow))
weather_data_test$Location <- as.numeric(factor(weather_data_test$Location))
weather_data_test$RainTomorrow[weather_data_test$RainTomorrow == "1"] <- 0
weather_data_test$RainTomorrow[weather_data_test$RainTomorrow == "2"] <- 1
preObj <- preProcess(subset(weather_data_test, select = -c(RainTomorrow)),
method=c("range"), rangebounds = c(0, 1))
class <- weather_data_test$RainTomorrow
weather_data_test <- predict(preObj, subset(weather_data_test, select = -c(RainTomorrow)))
weather_data_test$RainTomorrow <- class
model_one <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = 1,
lifesign = "full")
#plot(model_one)
model_one_rep <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = 1,
rep = 3,
lifesign = "minimal")
model_multiple_rep <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = 4,
rep = 5,
lifesign = "minimal")
model_multiple_layers <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = c(2, 1),
lifesign = "minimal")
podaci <- read.csv("weather_data_train.csv", fileEncoding = 'UTF-8')
podaci <- podaci[-c(70, 550), ]
Location_not_na <- subset(podaci, is.na(Location) == FALSE)$Location
MinTemp_not_na <- subset(podaci, is.na(MinTemp) == FALSE)$MinTemp
MaxTemp_not_na <- subset(podaci, is.na(MaxTemp) == FALSE)$MaxTemp
Rainfall_not_na <- subset(podaci, is.na(Rainfall) == FALSE)$Rainfall
WindGustDir_not_na <- subset(podaci, is.na(WindGustDir) == FALSE)$WindGustDir
WindGustSpeed_not_na <- subset(podaci, is.na(WindGustSpeed) == FALSE)$WindGustSpeed
RainToday_not_na <- subset(podaci, is.na(RainToday) == FALSE)$RainToday
Humidity9am_not_na <- subset(podaci, is.na(Humidity9am) == FALSE)$Humidity9am
Cloud9am_not_na <- subset(podaci, is.na(Cloud9am) == FALSE)$Cloud9am
Cloud5pm_not_na <- subset(podaci, is.na(Cloud5pm) == FALSE)$Cloud5pm
Pressure9am_not_na <- subset(podaci, is.na(Pressure9am) == FALSE)$Pressure9am
WindDir9am_not_na <- subset(podaci, is.na(WindDir9am) == FALSE)$WindDir9am
WindDir3pm_not_na <- subset(podaci, is.na(WindDir3pm) == FALSE)$WindDir3pm
RainTomorrow_not_na <- subset(podaci, is.na(RainTomorrow) == FALSE)$RainTomorrow
#Zamjena nedostajucih vrijednosti kolone MinTemp
podaci_stari <- podaci
median <- median(MinTemp_not_na)
for (i in 1 : length(podaci$MinTemp))
{
if (is.na(podaci$MinTemp[i]) == TRUE)
{
podaci$MinTemp[i] <- median
}
}
#Zamjena nedostajucih vrijednosti kolone MaxTemp
podaci_stari <- podaci
median <- median(MaxTemp_not_na)
for (i in 1 : length(podaci$MaxTemp))
{
if (is.na(podaci$MaxTemp[i]) == TRUE)
{
podaci$MaxTemp[i] <- median
}
}
#Odbacivanje outlier-a za MaxTemp
median <- median(MaxTemp_not_na)
for (i in 1 : 9)
{
index_maximuma <- which.max(podaci$MaxTemp)
podaci$MaxTemp[index_maximuma] <- median
index_minimuma <- which.min(podaci$MaxTemp)
podaci$MaxTemp[index_minimuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Rainfall
podaci_stari <- podaci
median <- median(Rainfall_not_na)
for (i in 1 : length(podaci$Rainfall))
{
if (is.na(podaci$Rainfall[i]) == TRUE)
{
podaci$Rainfall[i] <- median
}
}
#Odbacivanje outlier-a kolone Rainfall
median <- median(Rainfall_not_na)
for (i in 1 : 50)
{
index_maximuma <- which.max(podaci$Rainfall)
podaci$Rainfall[index_maximuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone WindGustSpeed
podaci_stari <- podaci
median <- median(WindGustSpeed_not_na)
for (i in 1 : length(podaci$WindGustSpeed))
{
if (is.na(podaci$WindGustSpeed[i]) == TRUE)
{
podaci$WindGustSpeed[i] <- median
}
}
#Odbacivanje outlier-a za WindGustSpeed
median <- median(WindGustSpeed_not_na)
for (i in 1 : 5)
{
index_minimuma <- which.min(podaci$WindGustSpeed)
podaci$WindGustSpeed[index_minimuma] <- median
}
for (i in 1 : 50)
{
index_maximuma <- which.max(podaci$WindGustSpeed)
podaci$WindGustSpeed[index_maximuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Humidity9am
podaci_stari <- podaci
median <- median(Humidity9am_not_na)
for (i in 1 : length(podaci$Humidity9am))
{
if (is.na(podaci$Humidity9am[i]) == TRUE)
{
podaci$Humidity9am[i] <- median
}
}
#Odbacivanje outlier-a za Humidity9am
median <- median(Humidity9am_not_na)
for (i in 1 : 50)
{
index_minimuma <- which.min(podaci$Humidity9am)
podaci$Humidity9am[index_minimuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Cloud9am
podaci_stari <- podaci
median <- median(Cloud9am_not_na)
for (i in 1 : length(podaci$Cloud9am))
{
if (is.na(podaci$Cloud9am[i]) == TRUE)
{
podaci$Cloud9am[i] <- median
}
}
#Zamjena nedostajucih vrijednosti kolone Pressure9am
podaci_stari <- podaci
median <- median(Pressure9am_not_na)
for (i in 1 : length(podaci$Pressure9am))
{
if (is.na(podaci$Pressure9am[i]) == TRUE)
{
podaci$Pressure9am[i] <- median
}
}
#Odbacivanje outlier-a za Pressure9am
median <- median(Pressure9am_not_na)
for (i in 1 : 30)
{
index_minimuma <- which.min(podaci$Pressure9am)
podaci$Pressure9am[index_minimuma] <- median
}
for (i in 1 : 20)
{
index_maximuma <- which.max(podaci$Pressure9am)
podaci$Pressure9am[index_maximuma] <- median
}
#Zamjena nedostajucih vrijednosti kolone Cloud5pm
podaci_stari <- podaci
median <- median(Cloud5pm_not_na)
for (i in 1 : length(podaci$Cloud5pm))
{
if (is.na(podaci$Cloud5pm[i]) == TRUE)
{
podaci$Cloud5pm[i] <- median
}
}
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
#Popunjavanje nedostajucih vrijednosti kolone Location
podaci$Location[is.na(podaci$Location)] = getmode(Location_not_na)
#Popunjavanje nedostajucih vrijednosti kolone WindGustDir
podaci$WindGustDir[is.na(podaci$WindGustDir)] = getmode(WindGustDir_not_na)
#Popunjavanje nedostajucih vrijednosti kolone RainToday
podaci$RainToday[is.na(podaci$RainToday)] = getmode(RainToday_not_na)
#Popunjavanje nedostajucih vrijednosti kolone WindDir9am
podaci$WindDir9am[is.na(podaci$WindDir9am)] = getmode(WindDir9am_not_na)
#Popunjavanje nedostajucih vrijednosti kolone WindDir3pm
podaci$WindDir3pm[is.na(podaci$WindDir3pm)] = getmode(WindDir3pm_not_na)
#Odbacivanje varijabli sa visokim stepenom korelacije
podaci <- select(podaci, -MaxTemp, -Cloud5pm)
#normalizacija podataka
max <- max(podaci$Pressure9am)
min <- min(podaci$Pressure9am)
podaci <- mutate(podaci, Pressure9am = (Pressure9am - min) / (max - min))
#Pretvaranje kategorickih varijabli u faktorske
podaci$WindGustDir <- factor(podaci$WindGustDir)
podaci$WindDir9am <- factor(podaci$WindDir9am)
podaci$WindDir3pm <- factor(podaci$WindDir3pm)
podaci$RainToday <- factor(podaci$RainToday)
podaci$RainTomorrow <- factor(podaci$RainTomorrow)
#Podjela dataset-a na trening i testni skup
set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]
end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
# priprema podataka
podaci$WindGustDir <- as.numeric(factor(podaci$WindGustDir))
podaci$WindDir9am <- as.numeric(factor(podaci$WindDir9am))
podaci$WindDir3pm <- as.numeric(factor(podaci$WindDir3pm))
podaci$RainToday <- as.numeric(factor(podaci$RainToday))
podaci$RainTomorrow <- as.numeric(factor(podaci$RainTomorrow))
podaci$Location <- as.numeric(factor(podaci$Location))
# normalizacija podataka
podaci$RainTomorrow[podaci$RainTomorrow == "1"] <- 0
podaci$RainTomorrow[podaci$RainTomorrow == "2"] <- 1
preObj <- preProcess(subset(podaci, select = -c(RainTomorrow)),
method=c("range"), rangebounds = c(0, 1))
class <- podaci$RainTomorrow
podaci <- predict(preObj, subset(podaci, select = -c(RainTomorrow)))
podaci$RainTomorrow <- class
# podjela na trening i testni skup
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]
end <- length(podaci$RainTomorrow)
n <- as.integer(0.8 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
model_one <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = 1,
lifesign = "full")
#plot(model_one)
model_one_rep <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = 1,
rep = 3,
lifesign = "minimal")
model_multiple_rep <- neuralnet(formula = RainTomorrow ~ .,
data = podaci_train,
linear.output = FALSE,
err.fct = "ce",
hidden = 4,
rep = 5,
lifesign = "minimal")
