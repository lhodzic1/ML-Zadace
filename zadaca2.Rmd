---
title: "Zadaca 2"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dataPreparation)
library(tidyverse)
#library(ggplot2)
#library(reshape2)
#library(PerformanceAnalytics)
#library(GGally)
library(rpart)
#library(rpart.plot)
library(caret)
library(pROC)
library(plyr)
library(dplyr)
library(ROSE)
library(ipred)
#library(VIM)
library(class)
library(tune)
library(e1071)
library(neuralnet)
library(caTools)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
podaci <- read.csv("weather_data_train.csv", fileEncoding = 'UTF-8')
podaci <- podaci[-c(70, 550), ]
```

## **Priprema podataka**

```{r}
Location_not_na <- subset(podaci, is.na(Location) == FALSE)$Location
MinTemp_not_na <- subset(podaci, is.na(MinTemp) == FALSE)$MinTemp
MaxTemp_not_na <- subset(podaci, is.na(MaxTemp) == FALSE)$MaxTemp
Rainfall_not_na <- subset(podaci, is.na(Rainfall) == FALSE)$Rainfall
WindGustDir_not_na <- subset(podaci, is.na(WindGustDir) == FALSE)$WindGustDir
WindGustSpeed_not_na <- subset(podaci, is.na(WindGustSpeed) == FALSE)$WindGustSpeed
RainToday_not_na <- subset(podaci, is.na(RainToday) == FALSE)$RainToday
Humidity9am_not_na <- subset(podaci, is.na(Humidity9am) == FALSE)$Humidity9am
Cloud9am_not_na <- subset(podaci, is.na(Cloud9am) == FALSE)$Cloud9am
Cloud5pm_not_na <- subset(podaci, is.na(Cloud5pm) == FALSE)$Cloud5pm
Pressure9am_not_na <- subset(podaci, is.na(Pressure9am) == FALSE)$Pressure9am
WindDir9am_not_na <- subset(podaci, is.na(WindDir9am) == FALSE)$WindDir9am
WindDir3pm_not_na <- subset(podaci, is.na(WindDir3pm) == FALSE)$WindDir3pm
RainTomorrow_not_na <- subset(podaci, is.na(RainTomorrow) == FALSE)$RainTomorrow
```

```{r}
#Zamjena nedostajucih vrijednosti kolone MinTemp
podaci_stari <- podaci
median <- median(MinTemp_not_na)
for (i in 1 : length(podaci$MinTemp))
{
 if (is.na(podaci$MinTemp[i]) == TRUE)
 {
 podaci$MinTemp[i] <- median
 }
}
boxplot(podaci_stari$MinTemp, podaci$MinTemp)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone MaxTemp
podaci_stari <- podaci
median <- median(MaxTemp_not_na)
for (i in 1 : length(podaci$MaxTemp))
{
 if (is.na(podaci$MaxTemp[i]) == TRUE)
 {
 podaci$MaxTemp[i] <- median
 }
}

#Boxplot nakon popunjavanja nedostajucih vrijednosti
boxplot(podaci_stari$MaxTemp, podaci$MaxTemp)


#Odbacivanje outlier-a za MaxTemp
plot(podaci$MinTemp, podaci$MaxTemp)
        
median <- median(MaxTemp_not_na)
for (i in 1 : 9)
{
 index_maximuma <- which.max(podaci$MaxTemp)
 podaci$MaxTemp[index_maximuma] <- median
 index_minimuma <- which.min(podaci$MaxTemp)
 podaci$MaxTemp[index_minimuma] <- median
}

plot(podaci$MinTemp, podaci$MaxTemp)
boxplot(podaci$MaxTemp)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone Rainfall
podaci_stari <- podaci
median <- median(Rainfall_not_na)
for (i in 1 : length(podaci$Rainfall))
{
 if (is.na(podaci$Rainfall[i]) == TRUE)
 {
 podaci$Rainfall[i] <- median
 }
}
boxplot(podaci_stari$Rainfall, podaci$Rainfall)

#Odbacivanje outlier-a kolone Rainfall

plot(podaci$Rainfall, podaci$MinTemp)

median <- median(Rainfall_not_na)
for (i in 1 : 50)
{
 index_maximuma <- which.max(podaci$Rainfall)
 podaci$Rainfall[index_maximuma] <- median
}

plot(podaci$Rainfall, podaci$MinTemp)
boxplot(podaci$Rainfall)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone WindGustSpeed
podaci_stari <- podaci
median <- median(WindGustSpeed_not_na)
for (i in 1 : length(podaci$WindGustSpeed))
{
 if (is.na(podaci$WindGustSpeed[i]) == TRUE)
 {
 podaci$WindGustSpeed[i] <- median
 }
}
boxplot(podaci_stari$WindGustSpeed, podaci$WindGustSpeed)


#Odbacivanje outlier-a za WindGustSpeed
plot(podaci$WindGustSpeed, podaci$MinTemp)

median <- median(WindGustSpeed_not_na)
for (i in 1 : 5)
{
 index_minimuma <- which.min(podaci$WindGustSpeed)
 podaci$WindGustSpeed[index_minimuma] <- median
}
for (i in 1 : 50)
{
index_maximuma <- which.max(podaci$WindGustSpeed)
 podaci$WindGustSpeed[index_maximuma] <- median
}

plot(podaci$WindGustSpeed, podaci$MinTemp)
boxplot(podaci$WindGustSpeed)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone Humidity9am
podaci_stari <- podaci
median <- median(Humidity9am_not_na)
for (i in 1 : length(podaci$Humidity9am))
{
 if (is.na(podaci$Humidity9am[i]) == TRUE)
 {
 podaci$Humidity9am[i] <- median
 }
}
boxplot(podaci_stari$Humidity9am, podaci$Humidity9am)

plot(podaci$Humidity9am, podaci$MinTemp)

#Odbacivanje outlier-a za Humidity9am
median <- median(Humidity9am_not_na)

for (i in 1 : 50)
{
 index_minimuma <- which.min(podaci$Humidity9am)
 podaci$Humidity9am[index_minimuma] <- median
}

plot(podaci$Humidity9am, podaci$MinTemp)
boxplot(podaci$Humidity9am)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone Cloud9am
podaci_stari <- podaci
median <- median(Cloud9am_not_na)
for (i in 1 : length(podaci$Cloud9am))
{
 if (is.na(podaci$Cloud9am[i]) == TRUE)
 {
 podaci$Cloud9am[i] <- median
 }
}
boxplot(podaci_stari$Cloud9am, podaci$Cloud9am)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone Pressure9am
podaci_stari <- podaci
median <- median(Pressure9am_not_na)
for (i in 1 : length(podaci$Pressure9am))
{
 if (is.na(podaci$Pressure9am[i]) == TRUE)
 {
 podaci$Pressure9am[i] <- median
 }
}
boxplot(podaci_stari$Pressure9am, podaci$Pressure9am)

#Odbacivanje outlier-a za Pressure9am
plot(podaci$Pressure9am, podaci$MinTemp)

median <- median(Pressure9am_not_na)

for (i in 1 : 30)
{
 index_minimuma <- which.min(podaci$Pressure9am)
 podaci$Pressure9am[index_minimuma] <- median
}

for (i in 1 : 20)
{
 index_maximuma <- which.max(podaci$Pressure9am)
 podaci$Pressure9am[index_maximuma] <- median
}

plot(podaci$Pressure9am, podaci$MinTemp)
boxplot(podaci$Pressure9am)
```

```{r}
#Zamjena nedostajucih vrijednosti kolone Cloud5pm
podaci_stari <- podaci
median <- median(Cloud5pm_not_na)
for (i in 1 : length(podaci$Cloud5pm))
{
 if (is.na(podaci$Cloud5pm[i]) == TRUE)
 {
 podaci$Cloud5pm[i] <- median
 }
}
boxplot(podaci_stari$Cloud5pm, podaci$Cloud5pm)

```

```{r}
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}
```

```{r}
 #Popunjavanje nedostajucih vrijednosti kolone Location
 podaci$Location[is.na(podaci$Location)] = getmode(Location_not_na)
 
  #Popunjavanje nedostajucih vrijednosti kolone WindGustDir
 podaci$WindGustDir[is.na(podaci$WindGustDir)] = getmode(WindGustDir_not_na)
 
  #Popunjavanje nedostajucih vrijednosti kolone RainToday
 podaci$RainToday[is.na(podaci$RainToday)] = getmode(RainToday_not_na)
 
 #Popunjavanje nedostajucih vrijednosti kolone WindDir9am
 podaci$WindDir9am[is.na(podaci$WindDir9am)] = getmode(WindDir9am_not_na)
 
 #Popunjavanje nedostajucih vrijednosti kolone WindDir3pm
 podaci$WindDir3pm[is.na(podaci$WindDir3pm)] = getmode(WindDir3pm_not_na)
```

```{r}
#Odbacivanje varijabli sa visokim stepenom korelacije
podaci <- select(podaci, -MaxTemp, -Cloud5pm)
```

```{r}
#normalizacija podataka

max <- max(podaci$Pressure9am)
min <- min(podaci$Pressure9am)
podaci <- mutate(podaci, Pressure9am = (Pressure9am - min) / (max - min))
```

### **Podjela podataka na trening i testni set**

```{r}
#Pretvaranje kategorickih varijabli u faktorske


podaci$WindGustDir <- factor(podaci$WindGustDir)
podaci$WindDir9am <- factor(podaci$WindDir9am)
podaci$WindDir3pm <- factor(podaci$WindDir3pm)
podaci$RainToday <- factor(podaci$RainToday)
podaci$RainTomorrow <- factor(podaci$RainTomorrow)
```

```{r}
#Podjela dataset-a na trening i testni skup

set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]

end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

### Balansiranje podataka (zadaća 1)

```{r}
#podaci_stari <- podaci

hist(as.numeric(podaci$RainTomorrow))

#oversampling

oversample <- ovun.sample(RainTomorrow ~ ., data = podaci, method = "both",
N = 2500, p=0.4)$data

hist(as.numeric(oversample$RainTomorrow))

podaci <- oversample
```

```{r}
#Pretvaranje kategorickih varijabli u faktorske


podaci$WindGustDir <- factor(podaci$WindGustDir)
podaci$WindDir9am <- factor(podaci$WindDir9am)
podaci$WindDir3pm <- factor(podaci$WindDir3pm)
podaci$RainToday <- factor(podaci$RainToday)
podaci$RainTomorrow <- factor(podaci$RainTomorrow)

#Podjela dataset-a na trening i testni skup

set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]

end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

### SMOTE balansiranje podataka

```{r}
# pretvaranje kategorickih varijabli u numericke
podaci$WindGustDir <- as.numeric(factor(podaci$WindGustDir))
podaci$WindDir9am <- as.numeric(factor(podaci$WindDir9am))
podaci$WindDir3pm <- as.numeric(factor(podaci$WindDir3pm))
podaci$RainToday <- as.numeric(factor(podaci$RainToday))
podaci$Location <- as.numeric(factor(podaci$Location))

#SMOTE
library(smotefamily)
options(warn = -1)

new_data <- SMOTE(X = subset(podaci, select = -c(RainTomorrow)), target =
podaci$RainTomorrow, K = 7, dup_size = 0)$data
new_data$RainTomorrow <- factor(new_data$class)
new_data <- subset(new_data, select = -c(class))
podaci <- new_data

#podaci$WindGustDir <-as.factor(podaci$WindGustDir)
#podaci$WindDir9am <- as.factor(podaci$WindDir9am)
#podaci$WindDir3pm <- as.factor(podaci$WindDir3pm)
#podaci$RainToday <- as.factor(podaci$RainToday)
#podaci$Location <- as.factor(podaci$Location)

#Podjela dataset-a na trening i testni skup

set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]

end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

## Modeli klasifikacije

```{r}
draw_confusion_matrix <- function(cm)
{
 columns <- colnames(cm$table)
 rows <- rownames(cm$table)
 layout(matrix(c(1,1,2)))
 par(mar=c(2,2,2,2))
 plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n',
yaxt='n')
 title('CONFUSION MATRIX', cex.main=2)
 rect(150, 430, 240, 370, col='#3F97D0')
 text(195, 435, columns[1], cex=1.2)
 rect(250, 430, 340, 370, col='#F7AD50')
 text(295, 435, columns[2], cex=1.2)
 text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
 text(245, 450, 'Actual', cex=1.3, font=2)
 rect(150, 305, 240, 365, col='#F7AD50')
 rect(250, 305, 340, 365, col='#3F97D0')
 text(140, 400, rows[1], cex=1.2, srt=90)
 text(140, 335, rows[2], cex=1.2, srt=90)
 res <- as.numeric(cm$table)
 text(195, 400, res[1], cex=1.6, font=2, col='white')
 text(195, 335, res[2], cex=1.6, font=2, col='white')
 text(295, 400, res[3], cex=1.6, font=2, col='white')
 text(295, 335, res[4], cex=1.6, font=2, col='white')
 plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main =
"DETAILS", xaxt='n', yaxt='n')
 text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
 text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
 text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
 text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
 text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
 text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
 text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
 text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
 text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
 text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)
 text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
 text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
 text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
 text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}
```

```{r}
# pomocna funkcija za bagging

predict_bagging <- function(podaci, podaci_test, lista,  k) {

  predictions_bagging <- c()
  
  for (i in 1:length(podaci_test$RainTomorrow)) {
    prediction_1 <- 0
    prediction_0 <- 0
    
    for (j in 1:k) {
      if(lista[j][[1]][i] == 1) {
        prediction_0 <- prediction_0 +  1
      } else {
         prediction_1 <- prediction_1 +  1
      }
    }
    
  #  predikcija = 'No'
    predikcija = 0
    if(prediction_1 > prediction_0) {
      # predikcija = 'Yes'
      predikcija = 1
    }
    
    predictions_bagging <- append(predictions_bagging, predikcija)
  }
  
  return(predictions_bagging)
}
```

```{r}
```

```{r}
```

### **KNN model predikcije**

```{r}
# priprema podataka
podaci$WindGustDir <- as.numeric(factor(podaci$WindGustDir))
podaci$WindDir9am <- as.numeric(factor(podaci$WindDir9am))
podaci$WindDir3pm <- as.numeric(factor(podaci$WindDir3pm))
podaci$RainToday <- as.numeric(factor(podaci$RainToday))
podaci$Location <- as.numeric(factor(podaci$Location))

#Podjela dataset-a na trening i testni skup

set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]

end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

```{r}
#Kreiranje modela
predictions <- knn(train = subset(podaci_train, select = -c(RainTomorrow)),
 test = subset(podaci_test, select = -c(RainTomorrow)),
 cl = podaci_train$RainTomorrow, k = 15)
cm <- confusionMatrix(data = predictions, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)
```

```{r}
#ROC kriva
#pred <- as.numeric(predictions)
#test_num <- as.numeric(podaci_test$RainTomorrow)
#lrROC <- roc(pred ~ test_num,smoothed = TRUE,
# arguments for ci
#ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
#plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
#print.auc=TRUE, show.thres=TRUE)
#sens.ci <- ci.se(lrROC)
#plot(sens.ci, type="shape", col="lightblue")

#ROC kriva

#predictions<-predict(model, newdata=podaci_test, type="prob")
predictions <- as.numeric(predictions)

roc <- roc(podaci_test$RainTomorrow, predictions, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

```{r}
#
```

#### Cross validacija

```{r}
# Pomocna funkcija za KNN

kfold_knn <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
   predictions <- knn(train = subset(train, select = -c(RainTomorrow)),
 test = subset(test, select = -c(RainTomorrow)),
 cl = train$RainTomorrow, k = 15)
  
  prediction <- factor(predictions)
  cm <- confusionMatrix(data = prediction, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za knn

bootstrap_knn <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
   
    
   predictions <- knn(train = subset(train, select = -c(RainTomorrow)),
 test = subset(test, select = -c(RainTomorrow)),
 cl = train$RainTomorrow, k = 15)
  
   predictions <- factor(predictions)
   
   cm <- confusionMatrix(data = predictions, reference = test$RainTomorrow)
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_knn(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- kfold_knn(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_knn(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- bootstrap_knn(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

#### Tuning hiperparametara

```{r}
tuning <- tune.knn(formula = RainTomorrow ~ .,
 x = subset(podaci, select = -c(RainTomorrow)),
 y = podaci$RainTomorrow,
 k = c(3, 5, 7, 9, 11, 13, 15, 17, 19, 21))
cat("Najbolja vrijednost k:", tuning$best.parameters$k, "\n")
cat("Najveća tačnost:", 1.00 - tuning$best.performance)
plot(tuning)
```

#### Model nakon tuninga

```{r}
#Kreiranje modela
predictions <- knn(train = subset(podaci_train, select = -c(RainTomorrow)),
 test = subset(podaci_test, select = -c(RainTomorrow)),
 cl = podaci_train$RainTomorrow, k = 3)
cm <- confusionMatrix(data = predictions, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)
```

#### 

```{r}
predictions <- as.numeric(predictions)

roc <- roc(podaci_test$RainTomorrow, predictions, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

#### Bagging

```{r}
# pomocna funkcija za bagging knn

begging_knn <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

    
   predictions <- knn(train = subset(train, select = -c(RainTomorrow)),
 test = subset(podaci_test, select = -c(RainTomorrow)),
 cl = train$RainTomorrow, k = 15)
   
   predictions <- as.numeric(predictions)
  
#   predictions <- factor(predictions)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}

lista <- begging_knn(podaci, podaci_test, 10)

pred <- predict_bagging(podaci, podaci_test, lista, 10)
pred <- factor(pred)

cm <- confusionMatrix(data = pred, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)

pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")

```

### **Naivni Bayesov model predikcije**

```{r}
# Feature Scaling DA LI TREBA???
#train_scale <- scale(podaci_train[, 1:4])
#test_scale <- scale(podaci_test[, 1:4])
 
# Fitting Naive Bayes Model
# to training dataset
set.seed(120)  # Setting Seed
classifier_cl <- naiveBayes(RainTomorrow ~ ., data = podaci_train)
#classifier_cl
 
# Predicting on test data'
y_pred <- predict(classifier_cl, newdata = podaci_test)
 
# Confusion Matrix
cm <- table(podaci_test$RainTomorrow, y_pred)
 
# Model Evaluation
cm = confusionMatrix(cm)
draw_confusion_matrix(cm)
```

```{r}
#ROC kriva

predictions<-predict(classifier_cl, newdata=podaci_test, type="raw")

roc <- roc(podaci_test$RainTomorrow, predictions[, 2], percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")

```

#### Cross validacija

```{r}
# Pomocna funkcija za naivni bayes

kfold_bayes <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
   set.seed(120)  # Setting Seed
  classifier_cl <- naiveBayes(RainTomorrow ~ ., data = train)
 
  # Predicting on test data'
  y_pred <- predict(classifier_cl, newdata = test)
   
  cm <- confusionMatrix(data = y_pred, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za bayes

bootstrap_bayes <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
   
    
    set.seed(120)  # Setting Seed
  classifier_cl <- naiveBayes(RainTomorrow ~ ., data = train)
 
  # Predicting on test data'
  y_pred <- predict(classifier_cl, newdata = test)
   
  cm <- confusionMatrix(data = y_pred, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_bayes(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- kfold_bayes(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_bayes(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- bootstrap_bayes(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

#### Bagging

```{r}
# pomocna funkcija za bagging naivni bayes

begging_bayes <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

   set.seed(120)  # Setting Seed
  classifier_cl <- naiveBayes(RainTomorrow ~ ., data = train)
 
  # Predicting on test data'
  y_pred <- predict(classifier_cl, newdata = podaci_test)
  
  y_pred <- as.numeric(y_pred)
   
   lista <- append(lista, list(y_pred))
   
 }

 return (lista)
}
```

```{r}
lista_bayes <- begging_bayes(podaci, podaci_test, 10)

pred <- predict_bagging(podaci, podaci_test, lista_bayes, 10)
pred <- factor(pred)

cm <- confusionMatrix(data = pred, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)

pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

### **Model logističke regresije**

```{r}
#Pretvaranje kategorickih varijabli sa statičkim nivoima u faktorske

podaci$WindGustDir <- as.factor(podaci$WindGustDir)
podaci$WindDir9am <- as.factor(podaci$WindDir9am)
podaci$WindDir3pm <- as.factor(podaci$WindDir3pm)
podaci$RainToday <- as.factor(podaci$RainToday)
podaci$RainTomorrow <- as.factor(podaci$RainTomorrow)

#Lokacija ima promjenljiv broj nivoa
podaci$Location <- as.numeric(factor(podaci$Location))
```

```{r}
#Kreiranje modela
model <- glm(formula = RainTomorrow ~ ., data = podaci_train, family = binomial(link = "logit"))
predictions <- predict(model, newdata = subset(podaci_test, select = -
c(RainTomorrow)), type= "response")
predictions[predictions > 0.5] <- "Yes"
predictions[predictions <= 0.5] <- "No"
predictions <- factor(predictions, levels = c("No", "Yes"))
cm <- confusionMatrix(data = predictions, reference = podaci_test$RainTomorrow)
cat("Accuracy:", cm$overall[1])
```

```{r}
# konfuzijska matrica
draw_confusion_matrix(cm)

```

```{r}
#ROC kriva
prediction <- predict(model, podaci_test, type = "response")
roc <- roc(podaci_test$RainTomorrow, prediction,  percent = TRUE)

plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

#### Cross validacija

```{r}
# Pomocna funkcija za model logističke regresije

kfold_logistic <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
   model <- glm(formula = RainTomorrow ~ ., data = train, family = binomial(link = "logit"))
predictions <- predict(model, newdata = subset(test, select = -c(RainTomorrow)), type= "response")
  predictions[predictions > 0.5] <- "Yes"
  predictions[predictions <= 0.5] <- "No"
  predictions <- factor(predictions, levels = c("No", "Yes"))
  cm <- confusionMatrix(data = predictions, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za bayes

bootstrap_logistic <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
    
    
   model <- glm(formula = RainTomorrow ~ ., data = train, family = binomial(link = "logit"))
predictions <- predict(model, newdata = subset(test, select = -c(RainTomorrow)), type= "response")
  predictions[predictions > 0.5] <- "Yes"
  predictions[predictions <= 0.5] <- "No"
  predictions <- factor(predictions, levels = c("No", "Yes"))
  cm <- confusionMatrix(data = predictions, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_logistic(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- kfold_logistic(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_logistic(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- bootstrap_logistic(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

#### Bagging

```{r}
# pomocna funkcija za bagging logistic

begging_logistic <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

  model <- glm(formula = RainTomorrow ~ ., data = train, family = binomial(link = "logit"))
predictions <- predict(model, newdata = subset(podaci_test, select = -
c(RainTomorrow)), type= "response")
predictions[predictions > 0.5] <- 2
predictions[predictions <= 0.5] <- 1
#predictions <- factor(predictions, levels = c("No", "Yes"))
  
  #y_pred <- as.numeric(y_pred)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
lista_logistic <- begging_logistic(podaci, podaci_test, 10)

pred <- predict_bagging(podaci, podaci_test, lista_logistic, 10)
pred <- factor(pred)

cm <- confusionMatrix(data = pred, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)

pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

### **SVM model klasifikacije**

```{r}
#lokacija mora u numericke

library(e1071)
model <- svm(formula = RainTomorrow ~ ., data = podaci_train, kernel = "linear")
predictions <- predict(model, newdata = subset(podaci_test, select = -
c(RainTomorrow)))
cm <- confusionMatrix(data = predictions, reference = podaci_test$RainTomorrow)
cat("Accuracy:", cm$overall[1])

```

```{r}
# konfuzijska matrica
draw_confusion_matrix(cm)

```

```{r}
#ROC kriva

predictions<-predict(model, newdata=podaci_test, type="prob")
predictions <- as.numeric(predictions)

roc <- roc(podaci_test$RainTomorrow, predictions, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

```{r}
```

```{r}
```

#### Cross validacija

```{r}
# Pomocna funkcija za model svm

kfold_svm <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
  model <- svm(formula = RainTomorrow ~ ., data = train, kernel = "linear")
predictions <- predict(model, newdata = subset(test, select = -c(RainTomorrow)))
cm <- confusionMatrix(data = predictions, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za svm

bootstrap_svm <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
   
  model <- svm(formula = RainTomorrow ~ ., data = train, kernel = "linear")
predictions <- predict(model, newdata = subset(test, select = -c(RainTomorrow)))
cm <- confusionMatrix(data = predictions, reference = test$RainTomorrow)
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
#lokaciju treba pretvorit u numericke
list <- kfold_svm(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- kfold_svm(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_svm(podaci, 10)
acc <- list$acc
kappa <- list$kappa
cat("10-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
list <- bootstrap_svm(podaci, 5)
acc <- list$acc
kappa <- list$kappa
cat("5-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

#### Tuning hiperparametara

```{r}
# Tuning hiperparametara
#podaci$WindGustDir <- as.numeric(podaci$WindGustDir)
#podaci$WindDir9am <- as.numeric(podaci$WindDir9am)
#podaci$WindDir3pm <- as.numeric(podaci$WindDir3pm)
#podaci$RainToday <- as.numeric(podaci$RainToday)
#podaci$RainTomorrow <- as.numeric(podaci$RainTomorrow)
#podaci$Location <- as.numeric(factor(podaci$Location))

tuning <- tune.svm(formula = RainTomorrow ~ .,
 x = subset(podaci, select = -c(RainTomorrow)),
 y = podaci$RainTomorrow,
 cost = c(1, 5, 10, 25, 50), gamma = c(0.001, 0.01,
0.1, 1))
cat("Najbolja vrijednost cost:", tuning$best.parameters$cost, "\n")
#cat("Najbolja vrijednost kernela:", tuning$best.parameters$kernel, "\n")
cat("Najbolja vrijednost gamma:", tuning$best.parameters$gamma, "\n")
cat("Najveća tačnost:", 1.00 - tuning$best.performance)
plot(tuning)
```

#### Model nakon tuninga

```{r}
#poslikati performanse sa svim kernelima

model_tuning <- svm(formula = RainTomorrow ~ ., data = podaci_train, kernel = "polynomial", cost=5, gamma=1)
predictions <- predict(model_tuning, newdata = subset(podaci_test, select = -
c(RainTomorrow)))
cm <- confusionMatrix(data = predictions, reference = podaci_test$RainTomorrow)
cat("Accuracy:", cm$overall[1])

#najbolji: polynomial
#drugi najbolji: linear

# konfuzijska matrica
draw_confusion_matrix(cm)
```

#### Bagging

```{r}

# pomocna funkcija za svm bagging

begging_svm <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

 model <- svm(formula = RainTomorrow ~ ., data = train, kernel = "linear")
 
predictions <- predict(model, newdata = subset(podaci_test, select = -
c(RainTomorrow)))
  
  predictions <- as.numeric(predictions)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
lista_svm <- begging_svm(podaci, podaci_test, 10)

pred <- predict_bagging(podaci, podaci_test, lista_svm, 10)
pred <- factor(pred)

cm <- confusionMatrix(data = pred, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)

pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

### **Neuralne mreže**

```{r}
# priprema podataka
podaci$WindGustDir <- as.numeric(factor(podaci$WindGustDir))
podaci$WindDir9am <- as.numeric(factor(podaci$WindDir9am))
podaci$WindDir3pm <- as.numeric(factor(podaci$WindDir3pm))
podaci$RainToday <- as.numeric(factor(podaci$RainToday))
podaci$RainTomorrow <- as.numeric(factor(podaci$RainTomorrow))
podaci$Location <- as.numeric(factor(podaci$Location))
```

```{r}
# normalizacija podataka
podaci$RainTomorrow[podaci$RainTomorrow == "1"] <- 0
podaci$RainTomorrow[podaci$RainTomorrow == "2"] <- 1
preObj <- preProcess(subset(podaci, select = -c(RainTomorrow)),
method=c("range"), rangebounds = c(0, 1))
class <- podaci$RainTomorrow
podaci <- predict(preObj, subset(podaci, select = -c(RainTomorrow)))
podaci$RainTomorrow <- class

# podjela na trening i testni skup
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]
end <- length(podaci$RainTomorrow)
n <- as.integer(0.8 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

#### Testiranje

```{r}
train_accuracy <- function(model)
{
 result <- model$net.result
 predictions <- result[[length(result)]]

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference =
factor(podaci_train$RainTomorrow))
 cat("Train accuracy:", cm$overall[1], "\n")
}

test_accuracy <- function(model)
{
 predictions <- compute(model, subset(podaci_test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference =
factor(podaci_test$RainTomorrow))
 cat("Test accuracy:", cm$overall[1], "\n")
 draw_confusion_matrix(cm)
 
predictions <- as.numeric(predictions)

roc <- roc(podaci_test$RainTomorrow, predictions, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
}

test_accuracy_test <- function(model)
{
 predictions <- compute(model, subset(weather_data_test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference =
factor(weather_data_test$RainTomorrow))
 cat("Test accuracy:", cm$overall[1], "\n")
 draw_confusion_matrix(cm)
}
```

#### Perceptron

```{r}
model_one <- neuralnet(formula = RainTomorrow ~ .,
 data = podaci_train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 lifesign = "full")

#plot(model_one)
```

```{r}
train_accuracy(model_one)
test_accuracy(model_one)
```

##### Cross validacija

```{r}
# Pomocna funkcija za perceptron

kfold_model_one <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
 model_one <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 lifesign = "full")
  
  predictions <- compute(model_one, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za perceptron

bootstrap_model_one <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
    
  model_one <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 lifesign = "full")
  
  predictions <- compute(model_one, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
 
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_model_one(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_model_one(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

##### Bagging

```{r}
# pomocna funkcija za model_one bagging

begging_model_one <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

 model_one <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 lifesign = "full")
  
  predictions <- compute(model_one, subset(podaci_test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 2
 predictions[predictions <= 0.5] <- 1
 #predictions <- factor(predictions)
  
 # predictions <- as.numeric(predictions)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
#lista_model_one <- begging_model_one(podaci, podaci_test, 3)

pred <- predict_bagging(podaci, podaci_test, lista_model_one, 3)
pred <- factor(pred)

podaci_test$RainTomorrow <- factor(podaci_test$RainTomorrow)

cm <- confusionMatrix(data = pred, reference = podaci_test$RainTomorrow)
draw_confusion_matrix(cm)

pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

#### Perceptron više epoha

```{r}
model_one_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = podaci_train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 rep = 3,
 lifesign = "minimal")
```

```{r}
train_accuracy(model_one_rep)
test_accuracy(model_one_rep)
```

##### Cross validacija

```{r}
# Pomocna funkcija za perceptron

kfold_model_one_rep <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
 model_one_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 rep = 3,
 lifesign = "minimal")
  
  predictions <- compute(model_one_rep, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za perceptron

bootstrap_model_one_rep <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
    
  model_one_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 rep = 3,
 lifesign = "minimal")
  
  predictions <- compute(model_one_rep, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
 
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_model_one_rep(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_model_one_rep(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

##### Bagging

```{r}
# pomocna funkcija za model_one bagging

begging_model_one_rep <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

   
  model_one_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 rep = 3,
 lifesign = "minimal")
  
  predictions <- compute(model_one_rep, subset(podaci_test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 2
 predictions[predictions <= 0.5] <- 1
 #predictions <- factor(predictions)
  
 # predictions <- as.numeric(predictions)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
lista_model_one_rep <- begging_model_one_rep(podaci, podaci_test, 3)

pred <- predict_bagging(podaci, podaci_test, lista_model_one_rep, 3)
pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

#### Preceptron sa više neurona

```{r}
model_multiple_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = podaci_train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 4,
 rep = 5,
 lifesign = "minimal")
```

```{r}
# Multiple-layers model
#odel_multiple_layers <- neuralnet(formula = RainTomorrow ~ .,
# data = podaci_train,
# linear.output = F,
# err.fct = "ce",
# hidden = c(2, 1),
# lifesign = "minimal")
#plot(model_multiple_layers)

train_accuracy(model_multiple_rep)
test_accuracy(model_multiple_rep)
```

##### Cross validacija

```{r}
# Pomocna funkcija za perceptron

kfold_model_multiple_rep <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
 model_multiple_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 4,
 rep = 5,
 lifesign = "minimal")
  
  predictions <- compute(model_multiple_rep, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za perceptron

bootstrap_model_multiple_rep <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
    
  model_multiple_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 4,
 rep = 5,
 lifesign = "minimal")
  
  predictions <- compute(model_multiple_rep, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
 
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_model_multiple_rep(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_model_multiple_rep(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

##### Bagging

```{r}
# pomocna funkcija za model_multiple_rep bagging

begging_model_multiple_rep <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

   
  model_multiple_rep <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 4,
 rep = 5,
 lifesign = "minimal")
  
  predictions <- compute(model_multiple_rep, subset(podaci_test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 2
 predictions[predictions <= 0.5] <- 1
 #predictions <- factor(predictions)
  
 # predictions <- as.numeric(predictions)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
lista_model_multiple_rep <- begging_model_multiple_rep(podaci, podaci_test, 3)

pred <- predict_bagging(podaci, podaci_test, lista_model_multiple_rep, 3)
pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

#### Višeslojni perceptron

```{r}
model_multiple_layers <- neuralnet(formula = RainTomorrow ~ .,
 data = podaci_train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = c(2, 1),
 lifesign = "minimal")
```

```{r}
train_accuracy(model_multiple_layers)
test_accuracy(model_multiple_layers)
```

##### Cross validacija

```{r}
# Pomocna funkcija za perceptron

kfold_model_multiple_layers <- function(podaci, k)
{
 folds <- split(podaci, cut(sample(1 : nrow(podaci)), k))
 acc <- rep(NA, length(folds))
 kappa <- rep(NA, length(folds))

 for (i in 1:length(folds))
 {
   test <- subset(ldply(folds[i], data.frame), select = -c(.id))
   train <- subset(ldply(folds[-i], data.frame), select = -c(.id))
   
model_multiple_layers <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = c(2, 1),
 lifesign = "minimal")
  
  predictions <- compute(model_multiple_layers, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
  
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}

# Pomocna funkcija za k-fold bootstrapping za perceptron

bootstrap_model_multiple_layers <- function(podaci, k)
{
 acc <- rep(NA, k)
 kappa <- rep(NA, k)
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
 test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]
    
model_multiple_layers <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = c(2, 1),
 lifesign = "minimal")
  
  predictions <- compute(model_multiple_layers, subset(test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 1
 predictions[predictions <= 0.5] <- 0
 predictions <- factor(predictions)
 cm <- confusionMatrix(data = predictions, reference = factor(test$RainTomorrow))
 
   acc[i] <- cm$overall[1]
   kappa[i] <- cm$overall[2]
 }
 list <- list("acc" = acc, "kappa" = kappa)
 return (list)
}
```

```{r}
list <- kfold_model_multiple_layers(podaci, 3)
acc <- list$acc
kappa <- list$kappa
cat("3-fold validacija\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

```{r}
list <- bootstrap_model_multiple_layers(podaci, 2)
acc <- list$acc
kappa <- list$kappa
cat("2-fold bootstrap\n")
cat("Najveća tačnost:", max(acc), ", fold:", which.max(acc))
cat(", najveća kappa:", max(kappa), ", fold:", which.max(kappa), "\n")
cat("Najmanja tačnost:", min(acc), ", fold:", which.min(acc))
cat(", najmanja kappa:", min(kappa), ", fold:", which.min(kappa), "\n")
cat("Srednja tačnost:", sum(acc) / length(acc))
cat(", srednja kappa:", sum(kappa) / length(kappa), "\n\n")
```

##### Bagging

```{r}
# pomocna funkcija za multiple_layers bagging

begging_model_multiple_layers <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$RainTomorrow) / k)
 for (i in 1:k)
 {
# test <- podaci[sample(nrow(podaci), size = B), ]
   train <- podaci[sample(nrow(podaci), size = length(podaci$RainTomorrow) -B), ]

  model_multiple_layers <- neuralnet(formula = RainTomorrow ~ .,
 data = train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = c(2, 1),
 lifesign = "minimal")
  
  predictions <- compute(model_multiple_layers, subset(podaci_test, select = -c(RainTomorrow)))
 predictions <- predictions$net.result

 predictions[predictions > 0.5] <- 2
 predictions[predictions <= 0.5] <- 1
 #predictions <- factor(predictions)
  
 # predictions <- as.numeric(predictions)
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
lista_model_multiple_layers <- begging_model_multiple_layers(podaci, podaci_test, 2)

pred <- predict_bagging(podaci, podaci_test, lista_model_multiple_layers, 2)
pred <- as.numeric(pred)

roc <- roc(podaci_test$RainTomorrow, pred, percent = TRUE)
plot(roc$specificities, roc$sensitivities, type="l", lwd = 2, col ="blue", xlim = c(100, 0), ylim = c(0, 100))
abline(coef = c(100, -1), col = "gray60")
```

#### Tuning hiperparametara

```{r}
library(nnet)

tuning <- tune.nnet(formula = RainTomorrow ~ .,
 x = subset(podaci, select = -c(RainTomorrow)),
 y = podaci$RainTomorrow,
 size = c(1, 2, 5, 10), decay = c(1e-07, 1e-05, 1e03, 1e-01))
cat("Najbolja vrijednost size:", tuning$best.parameters$size, "\n")
cat("Najbolja vrijednost decay:", tuning$best.parameters$decay, "\n")
cat("Najveća tačnost:", 1.00 - tuning$best.performance)

```

```{r}
model_tuning <- neuralnet(formula = RainTomorrow ~ .,
 data = podaci_train,
 linear.output = FALSE,
 err.fct = "ce",
 hidden = 1,
 algorithm = "backprop",
 learningrate = 0.1,
 rep = 10,
 lifesign = "full")
```

```{r}
train_accuracy(model_tuning)
test_accuracy(model_tuning)
```

```{r}
```

```{r}
```

## Testiranje

```{r}
#balansirani podaci

model_tuning <- svm(formula = RainTomorrow ~ ., data = podaci_train, kernel = "polynomial", cost=5, gamma=1)
predictions <- predict(model_tuning, newdata = subset(podaci_test, select = -
c(RainTomorrow)))
cm <- confusionMatrix(data = predictions, reference = podaci_test$RainTomorrow)
cat("Accuracy:", cm$overall[1])

# konfuzijska matrica
draw_confusion_matrix(cm)
```

```{r}
weather_data_test <- read.csv("weather_data_test.csv", fileEncoding = 'UTF-8')

#Pretvaranje kategorickih varijabli u faktorske

#weather_data_test$WindGustDir <- factor(weather_data_test$WindGustDir)
#weather_data_test$WindDir9am <- factor(weather_data_test$WindDir9am)
#weather_data_test$WindDir3pm <- factor(weather_data_test$WindDir3pm)
#weather_data_test$RainToday <- factor(weather_data_test$RainToday)
#weather_data_test$RainTomorrow <- factor(weather_data_test$RainTomorrow)

#weather_data_test$WindGustDir <- factor(weather_data_test$WindGustDir, levels = levels(podaci$WindGustDir))
#weather_data_test$WindDir9am <- factor(weather_data_test$WindDir9am, levels = levels(podaci$WindDir9am))
#weather_data_test$WindDir3pm <- factor(weather_data_test$WindDir3pm, levels = levels(podaci$WindDir3pm))
#weather_data_test$RainToday <- factor(weather_data_test$RainToday, levels = levels(podaci$RainToday))
#weather_data_test$RainTomorrow <- factor(weather_data_test$RainTomorrow, levels = levels(podaci$RainTomorrow))

weather_data_test <- select(weather_data_test, -MaxTemp, -Cloud5pm)

max <- max(weather_data_test$Pressure9am)
min <- min(weather_data_test$Pressure9am)
weather_data_test <- mutate(weather_data_test, Pressure9am = (Pressure9am - min) / (max - min))

weather_data_test$WindGustDir <- as.numeric(factor(weather_data_test$WindGustDir))
weather_data_test$WindDir9am <- as.numeric(factor(weather_data_test$WindDir9am))
weather_data_test$WindDir3pm <- as.numeric(factor(weather_data_test$WindDir3pm))
weather_data_test$RainToday <- as.numeric(factor(weather_data_test$RainToday))
weather_data_test$RainTomorrow <- as.numeric(factor(weather_data_test$RainTomorrow))
weather_data_test$Location <- as.numeric(factor(weather_data_test$Location))


```

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAaCAYAAADFTB7LAAAAa0lEQVR42u3OywnAIBBAwcXSUoCW5D11xDoNCBGNv0MOecJOBSOi1OZMsJ4dvFxEJ1OQnMxBarIKEpNNkJbsBknJYZCSnAYJyVVQziNig7/nZkFEbhTE5HpBVO4dxOXKIDL3BLG5BJ1T6rsbMfep2CaMN00AAAAASUVORK5CYII= "Run Current Chunk")

```{r}
#predikcija

##svm i naivni bayes

#prediction <- predict(model, newdata = subset(weather_data_test, select = -c(RainTomorrow)))

#cm <- confusionMatrix(prediction, weather_data_test$RainTomorrow, positive = 'Yes')
#draw_confusion_matrix(cm)

#####logisticka
#predictions <- predict(model, newdata = subset(weather_data_test, select = -
#c(RainTomorrow)), type= "response")
#predictions[predictions > 0.5] <- "Yes"
#predictions[predictions <= 0.5] <- "No"
#predictions <- factor(predictions, levels = c("No", "Yes"))
#cm <- confusionMatrix(data = predictions, reference = weather_data_test$RainTomorrow)
#draw_confusion_matrix(cm)

##knn
#predictions <- knn(train = subset(podaci_train, select = -c(RainTomorrow)),
# test = subset(weather_data_test, select = -c(RainTomorrow)),
# cl = podaci_train$RainTomorrow, k = 3)
#cm <- confusionMatrix(data = predictions, reference = weather_data_test$RainTomorrow)
#draw_confusion_matrix(cm)

#neuralne
test_accuracy_test(model_one_rep)

#prediction <- predict(model_one_rep, newdata = subset(weather_data_test, select = -c(RainTomorrow)))

#cm <- confusionMatrix(prediction, weather_data_test$RainTomorrow, positive = 'Yes')
#draw_confusion_matrix(cm)
```

## Zadatak 2

```{r}
podaci$WeatherStability = -1

for (i in 1:length(podaci$Rainfall)) {
  k = 3
  if (podaci[i,]$Cloud9am < 5) {
    k = 1
  } else if (podaci[i,]$Cloud9am >= 5 && podaci[i,]$Cloud9am <= 10) {
    k = 2
  }
  vrijednost <- (podaci[i,]$Humidity9am - k)/(max(podaci$Humidity9am) - k)
  
  if (podaci[i,]$WindDir9am != podaci[i,]$WindDir3pm && podaci[i,]$Pressure9am > 1010 && podaci[i,]$Rainfall>= 4 && podaci[i,]$Rainfall <= 10 && podaci[i,]$RainToday == "Yes") {
    podaci[i,]$WeatherStability <- vrijednost
  } else {
    k = 3
    if (podaci[i,]$Cloud5pm < 5) {
      k = 1
    } else if (podaci[i,]$Cloud5pm >= 5 && podaci[i,]$Cloud5pm <= 10) {
      k = 2
    }
    vrijednost <- (podaci[i,]$Pressure9am - k)/(max(podaci$Pressure9am) - k)
  
    podaci[i,]$WeatherStability <- vrijednost
  }
}

podaci[podaci$WindGustSpeed > 60 & (podaci$MinTemp < 5 | podaci$MaxTemp > 39 & podaci$RainTomorrow == "Yes"),]$WeatherStability <- 0

#podaci[podaci$WindGustSpeed < 5 & podaci$Rainfall < 5 & podaci$MaxTemp - podaci$MinTemp < 4 & #podaci$RainTomorrow == "No",]$WeatherStability <- 1
```

### Kreiranje modela

```{r}
#podjela podataka na trening i testne
podaci$WindGustDir <- factor(podaci$WindGustDir)
podaci$WindDir9am <- factor(podaci$WindDir9am)
podaci$WindDir3pm <- factor(podaci$WindDir3pm)
podaci$RainToday <- factor(podaci$RainToday)
podaci$RainTomorrow <- factor(podaci$RainTomorrow)

set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]

end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

```{r}
#model <- svm(formula = WeatherStability ~ ., data = podaci_train)
#predictions <- predict(model, newdata = subset(podaci_test, select = -c(WeatherStability)))

#plot(podaci_test$WeatherStability, podaci_test$MinTemp)
#points(predictions, podaci_test$MinTemp, col = "red", pch = 16)
#podaci$Location <- factor(podaci$Location)
#plot(podaci_test$WeatherStability, podaci_test$Pressure9am)
#points(predictions, podaci_test$Pressure9am, col = "blue", pch = 16)

#linearMod <- lm(WeatherStability ~ , data=podaci_train)

linearMod = lm(WeatherStability~MaxTemp+MinTemp+Location + Rainfall + WindGustDir + WindGustSpeed + RainToday + Humidity9am + Cloud9am + Pressure9am + WindDir9am + WindDir3pm + Cloud5pm + RainTomorrow, data=podaci_train)

summary(linearMod)

predictions <- predict(linearMod, newdata = subset(podaci_test, select = -c(WeatherStability)))
```

### Testiranje modela

```{r}
library(Metrics)

RMSE <- rmse(podaci_test$WeatherStability, predictions)
cat("RMSE:", RMSE, "\n")

#predictions <- predict(linearMod, newdata = subset(podaci_test, select = -c(WeatherStability)))

mae_metrika <- mae(podaci_test$WeatherStability, predictions)
cat("MAE: ", mae_metrika, "\n")
```

### Unapređenje modela

```{r}
cat(median(residuals(linearMod)))
plot(podaci_train$WeatherStability, residuals(linearMod))

lines(smooth.spline(podaci_train$WeatherStability, residuals(linearMod)), col = "red")
```

```{r}
predictions <- predict(linearMod, newdata = subset(podaci_test, select = -
c(WeatherStability)))
r2 = R2(podaci_test$WeatherStability, predictions, form = "traditional")
VIF = 1 / (1 - r2)
cat("VIF:", VIF)
```

```{r}


```

```{r}
library(car)

cat("Rezultat Durbin-Watsonovog testa:",
durbinWatsonTest(linearMod$residuals), "\n")
```

```{r}
#Odbacivanje varijabli sa visokim stepenom korelacije
#podaci <- select(podaci, -MaxTemp, -Cloud5pm)

#Podjela dataset-a na trening i testni skup

set.seed(2222)
rows <- sample(nrow(podaci))
podaci <- podaci[rows, ]

end <- length(podaci$Location)
n <- as.integer(0.80 * end)
podaci_train <- podaci[1 : n, ]
podaci_test <- podaci[(n + 1) : end, ]
```

```{r}

```

### Prikaz unapređenja modela

```{r}
linearMod = lm(WeatherStability~ MinTemp+Location + Rainfall + WindGustDir + WindGustSpeed + RainToday + Humidity9am + Cloud9am + Pressure9am + WindDir9am + WindDir3pm  + RainTomorrow, data=podaci_train)

summary(linearMod)

predictions <- predict(linearMod, newdata = subset(podaci_test, select = -c(WeatherStability)))

RMSE <- rmse(podaci_test$WeatherStability, predictions)
cat("RMSE:", RMSE, "\n")

mae_metrika <- mae(podaci_test$WeatherStability, predictions)
cat("MAE: ", mae_metrika, "\n")
```

### Ensamble tehnike - bagging

```{r}
# pomocna funkcija za bagging
predict_bagging <- function(podaci, podaci_test, lista,  k) {

  predictions_bagging <- c()
  
  for (i in 1:length(podaci_test$WeatherStability)) {
    suma <- 0
    
    for (j in 1:k) {
      suma <- suma + lista[j][[1]][i]
    }
    
    predictions_bagging <- append(predictions_bagging, suma/k)
  }
  
  return(predictions_bagging)
}

# pomocna funkcija za svm bagging
begging_lm <- function(podaci, podaci_test, k)
{
 lista <- vector(mode = "list", length = 0)
 #lista <- list(, 0)
  
 B <- as.integer(length(podaci$WeatherStability) / k)
 for (i in 1:k)
 {
   train_data <- podaci[sample(nrow(podaci), size = length(podaci$WeatherStability) -B), ]

 linearMod = lm(WeatherStability~ MinTemp+Location + Rainfall + WindGustDir + WindGustSpeed + RainToday + Humidity9am + Cloud9am + Pressure9am + WindDir9am + WindDir3pm  + RainTomorrow, data=train_data)
 
 predictions <- predict(linearMod, newdata = subset(podaci_test, select = -c(WeatherStability)))
   
   lista <- append(lista, list(predictions))
   
 }

 return (lista)
}
```

```{r}
lista_lm <- begging_lm(podaci, podaci_test, 30)
pred <- predict_bagging(podaci, podaci_test, lista_lm, 30)

RMSE <- rmse(podaci_test$WeatherStability, pred)
cat("RMSE:", RMSE, "\n")

mae_metrika <- mae(podaci_test$WeatherStability, pred)
cat("MAE: ", mae_metrika, "\n")
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
